#!/usr/bin/env python3.8
# @generated by pegen from regex-grammar/regex.gram

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser

from . import syntax as s

# Keywords and soft keywords are listed at the end of the parser definition.
class GeneratedParser(Parser):

    @memoize
    def start(self) -> Optional[list [s . Def]]:
        # start: rule+ $
        mark = self._mark()
        if (
            (rs := self._loop1_1())
            and
            (self.expect('ENDMARKER'))
        ):
            return rs;
        self._reset(mark)
        return None;

    @memoize
    def rule(self) -> Optional[Any]:
        # rule: (group_rule | def_rule) NEWLINE*
        mark = self._mark()
        if (
            (r := self._tmp_2())
            and
            (self._loop0_3(),)
        ):
            return r;
        self._reset(mark)
        return None;

    @memoize
    def group_rule(self) -> Optional[Any]:
        # group_rule: 'group' NAME '=' exprs
        mark = self._mark()
        if (
            (self.expect('group'))
            and
            (name := self.name())
            and
            (self.expect('='))
            and
            (exprs := self.exprs())
        ):
            return s . GroupDef ( name . string , exprs );
        self._reset(mark)
        return None;

    @memoize
    def def_rule(self) -> Optional[Any]:
        # def_rule: 'def' NAME '=' exprs
        mark = self._mark()
        if (
            (self.expect('def'))
            and
            (name := self.name())
            and
            (self.expect('='))
            and
            (exprs := self.exprs())
        ):
            return s . NameDef ( name . string , exprs );
        self._reset(mark)
        return None;

    @memoize
    def exprs(self) -> Optional[Any]:
        # exprs: expr+
        mark = self._mark()
        if (
            (_loop1_4 := self._loop1_4())
        ):
            return _loop1_4;
        self._reset(mark)
        return None;

    @memoize_left_rec
    def expr(self) -> Optional[Any]:
        # expr: or_expr | optional_group_expr | rule_with_range_expr | rule_with_count_expr | rule_mention_expr | literal_expr
        mark = self._mark()
        if (
            (or_expr := self.or_expr())
        ):
            return or_expr;
        self._reset(mark)
        if (
            (optional_group_expr := self.optional_group_expr())
        ):
            return optional_group_expr;
        self._reset(mark)
        if (
            (rule_with_range_expr := self.rule_with_range_expr())
        ):
            return rule_with_range_expr;
        self._reset(mark)
        if (
            (rule_with_count_expr := self.rule_with_count_expr())
        ):
            return rule_with_count_expr;
        self._reset(mark)
        if (
            (rule_mention_expr := self.rule_mention_expr())
        ):
            return rule_mention_expr;
        self._reset(mark)
        if (
            (literal_expr := self.literal_expr())
        ):
            return literal_expr;
        self._reset(mark)
        return None;

    @logger
    def or_expr(self) -> Optional[Any]:
        # or_expr: expr '|' expr
        mark = self._mark()
        if (
            (e1 := self.expr())
            and
            (self.expect('|'))
            and
            (e2 := self.expr())
        ):
            return s . OrExpr ( e1 , e2 );
        self._reset(mark)
        return None;

    @memoize
    def optional_group_expr(self) -> Optional[Any]:
        # optional_group_expr: '[' exprs ']'
        mark = self._mark()
        if (
            (self.expect('['))
            and
            (exprs := self.exprs())
            and
            (self.expect(']'))
        ):
            return s . OptionalGroupExpr ( exprs );
        self._reset(mark)
        return None;

    @memoize
    def rule_with_count_expr(self) -> Optional[Any]:
        # rule_with_count_expr: NAME '{' NUMBER '}'
        mark = self._mark()
        if (
            (name := self.name())
            and
            (self.expect('{'))
            and
            (c1 := self.number())
            and
            (self.expect('}'))
        ):
            return s . RuleCountExpr ( name . string , c1 . string );
        self._reset(mark)
        return None;

    @memoize
    def rule_with_range_expr(self) -> Optional[Any]:
        # rule_with_range_expr: NAME '{' NUMBER ',' NUMBER '}'
        mark = self._mark()
        if (
            (name := self.name())
            and
            (self.expect('{'))
            and
            (c1 := self.number())
            and
            (self.expect(','))
            and
            (c2 := self.number())
            and
            (self.expect('}'))
        ):
            return s . RuleRangeExpr ( name . string , c1 . string , c2 . string );
        self._reset(mark)
        return None;

    @memoize
    def rule_mention_expr(self) -> Optional[Any]:
        # rule_mention_expr: NAME
        mark = self._mark()
        if (
            (name := self.name())
        ):
            return s . RuleExpr ( name . string );
        self._reset(mark)
        return None;

    @memoize
    def literal_expr(self) -> Optional[Any]:
        # literal_expr: STRING
        mark = self._mark()
        if (
            (string := self.string())
        ):
            return s . LiteralExpr ( string . string );
        self._reset(mark)
        return None;

    @memoize
    def _loop1_1(self) -> Optional[Any]:
        # _loop1_1: rule
        mark = self._mark()
        children = []
        while (
            (rule := self.rule())
        ):
            children.append(rule)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_2(self) -> Optional[Any]:
        # _tmp_2: group_rule | def_rule
        mark = self._mark()
        if (
            (group_rule := self.group_rule())
        ):
            return group_rule;
        self._reset(mark)
        if (
            (def_rule := self.def_rule())
        ):
            return def_rule;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_3(self) -> Optional[Any]:
        # _loop0_3: NEWLINE
        mark = self._mark()
        children = []
        while (
            (_newline := self.expect('NEWLINE'))
        ):
            children.append(_newline)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_4(self) -> Optional[Any]:
        # _loop1_4: expr
        mark = self._mark()
        children = []
        while (
            (expr := self.expr())
        ):
            children.append(expr)
            mark = self._mark()
        self._reset(mark)
        return children;

    KEYWORDS = ('def', 'group')
    SOFT_KEYWORDS = ()


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
